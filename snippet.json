{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"1": {
		"prefix": "maincode",
		"body": [
		  "/* God is Great !",
		  "    Author : SANIDHIYA */",
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "void solve()",
		  "{",
		  "    ",
		  "}",
		  "int main()",
		  "{",
		  "ios_base::sync_with_stdio(false);",
		  "cout.tie(NULL);",
		  "cin.tie(NULL);",
		  "solve();",
		  "return 0;",
		  "}"
		],
		"description": ""
	  },

	  "2": {
		"prefix": "dsu",
		"body": [
		  "class DisjointSet{",
		  "    vector<int> parent,rank;",
		  "    int n;",
		  "    public : ",
		  "    DisjointSet(int n){",
		  "        this->n = n;",
		  "        this->parent = vector<int>(n + 1);",
		  "        this->rank = vector<int>(n+ 1);",
		  "        for(int i = 1; i <= n ;i ++)",
		  "        parent[i] = i;",
		  "    }",
		  "    int findparent(int u){",
		  "        if(parent[u] == u) return u;",
		  "        return parent[u] = findparent(parent[u]);",
		  "    }",
		  "    void Union(int u, int v){",
		  "        int parent_u = findparent(u);",
		  "        int parent_v = findparent(v);",
		  "        if(rank[parent_u] > rank[parent_v]){",
		  "            parent[parent_v] = parent_u;",
		  "            rank[parent_u] ++ ;",
		  "        }else{",
		  "            parent[parent_u] = parent_v;",
		  "            rank[parent_v] ++ ;",
		  "        }",
		  "        ",
		  "    }",
		  "};"
		],
		"description": ""
	  },
	  "3": {
		"prefix": "maths",
		"body": [
		  "const int mod = 998244353;",
		  "const int n = 1e5 + 5;",
		  "",
		  "unsigned long long power(unsigned long long x,int y)",
		  "{",
		  "    unsigned long long res = 1;",
		  "    x = x % mod; ",
		  "    while (y > 0)",
		  "    {",
		  "        if (y & 1)",
		  "            res = (res * x) % mod;",
		  "        y = y >> 1;",
		  "        x = (x * x) % mod;",
		  "    }",
		  "    return res;",
		  "}",
		  "unsigned long long modInverse(unsigned long long n)",
		  "{",
		  "    return power(n, mod - 2);",
		  "}",
		  "unsigned long long nCrModPFermat(unsigned long long n,int r)",
		  "{",
		  "    unsigned long long fac[n + 1];",
		  "    fac[0] = 1;",
		  "    for (int i = 1; i <= n; i++)",
		  "    fac[i] = (fac[i - 1] * i) % mod;",
		  "",
		  "    if (n < r)",
		  "        return 0;",
		  "    if (r == 0)",
		  "        return 1;",
		  "  ",
		  "    return (fac[n] * modInverse(fac[r]) % mod",
		  "            * modInverse(fac[n - r]) % mod)",
		  "           % mod;",
		  "}"
		],
		"description": ""
	  },
	  "4": {
		"prefix": "sieve",
		"body": [
		  "const int MAX = 1e7 + 5;",
		  "bool v[MAX];",
		  "int len, sp[MAX];",
		  "void Sieve(){",
		  "    for (int i = 2; i < MAX - 2; i += 2)	sp[i] = 2;",
		  "    for (long long int i = 3; i < MAX - 2; i += 2){",
		  "        if (!v[i]){",
		  "            sp[i] = i;",
		  "            for (long long int j = i; (j*i) < MAX; j += 2){",
		  "                if (!v[j*i])	v[j*i] = true, sp[j*i] = i;",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "vector <int> factorize(int k) {",
		  "    vector <int> ans;",
		  "    while(k>1) {",
		  "        ans.push_back(sp[k]);",
		  "        k/=sp[k];",
		  "    }",
		  "    return ans;",
		  "}",
		  " "
		],
		"description": ""
	  },
	  "5": {
		"prefix": "PBDS",
		"body": [
		  "#include<ext/pb_ds/assoc_container.hpp>",
		  "#include<ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> T_set; // PBDS_set",
		  "typedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> T_multiset; // PBDS_multiset"
		],
		"description": ""
	  },
	  "6": {
		"prefix": "lca",
		"body": [
		  "class LCA{",
		  "    int n, l;",
		  "    vector<vector<int>> adj;",
		  "        int timer;",
		  "    vector<int> tin, tout,depth;",
		  "    vector<vector<int>> up;",
		  "",
		  "    public : ",
		  "    LCA(int n){",
		  "        this->n = n;",
		  "        this->adj = vector<vector<int>>(n + 1);",
		  "        this->depth = vector<int>(n + 1);",
		  "    } ",
		  "",
		  "    void addEdge(int u, int v){",
		  "        adj[u].push_back(v);",
		  "        adj[v].push_back(u);",
		  "    }",
		  "",
		  "    // Call Prerprocess Method before queries",
		  "    void preprocess(int root) {",
		  "        depth[root] = 0;",
		  "        tin.resize(n + 1);",
		  "        tout.resize(n + 1);",
		  "        timer = 0;",
		  "        this->l = ceil(log2(n));",
		  "        up.assign(n + 1, vector<int>(l + 1));",
		  "        dfs(root, root);",
		  "    }",
		  "",
		  "    void dfs(int v, int p)",
		  "    {",
		  "        tin[v] = ++timer;",
		  "        up[v][0] = p;",
		  "        for (int i = 1; i <= l; ++i)",
		  "            up[v][i] = up[up[v][i-1]][i-1];",
		  "",
		  "        for (int u : adj[v]) {",
		  "            if (u != p)",
		  "            {",
		  "                depth[u] = depth[v] + 1;",
		  "                dfs(u, v);",
		  "            }",
		  "        }",
		  "",
		  "        tout[v] = ++timer;",
		  "    }",
		  "",
		  "    bool is_ancestor(int u, int v)",
		  "    {",
		  "        return tin[u] <= tin[v] && tout[u] >= tout[v];",
		  "    }",
		  "",
		  "    int kthancestor(int node, int k)",
		  "    {",
		  "        if(depth[node] < k) return -1;",
		  "        for(int i = l ; i >= 0; i--){    ",
		  "            if(k&(1<<i))",
		  "                node = up[node][i];",
		  "            if(node == -1) return node;",
		  "        }",
		  "        return node;",
		  "    }",
		  "    ",
		  "",
		  "    int lca(int u, int v)",
		  "    {",
		  "        if (is_ancestor(u, v))",
		  "            return u;",
		  "        if (is_ancestor(v, u))",
		  "            return v;",
		  "        for (int i = l; i >= 0; --i) {",
		  "            if (!is_ancestor(up[u][i], v))",
		  "                u = up[u][i];",
		  "        }",
		  "        return up[u][0];",
		  "    }",
		  "",
		  "    int distance(int u, int v){",
		  "        int parent = this->lca(u, v);",
		  "        return depth[v] + depth[u] - 2*depth[parent];",
		  "    }",
		  "};"
		],
		"description": ""
	  }
	  

}
